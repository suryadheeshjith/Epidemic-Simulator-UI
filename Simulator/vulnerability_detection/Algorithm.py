import sys
import os
import ReadFile
import Simulate
import random
import matplotlib.pyplot as plt

class Vulnerable_Agents():
	def __init__(self):
		self.type = "Vulnerable Agents"

class Agent_Vulnerabilities():
	def __init__(self):
		self.type = "Agent Vulnerabilities"

class Vulnerable_Agent_MC1(Vulnerable_Agents):
	def __init__(self, world_obj):
		super().__init__()
		self.world_obj=world_obj
		self.agent_scores={}
		self.init_scores()

	def init_scores(self):
		agents_obj=ReadFile.ReadAgents(self.world_obj.agents_filename,self.world_obj.config_obj)
		for agent_index in agents_obj.agents.keys():
			self.agent_scores[agent_index]=0

	def update_agent_scores(self,agents_obj):
		for agent in agents_obj.agents.values():
			if agent.state=='Recovered' or agent.state=='Infected':
				self.agent_scores[agent.index]+=1

	def one_run(self):
		_,agents_obj,_=self.world_obj.one_world()
		self.update_agent_scores(agents_obj)

	def do_MC(self,num_runs):
		self.world_obj.st_list[1].progress(0.0)
		for i in range(num_runs):
			self.world_obj.st_list[0].write("Iteration : {0}".format(i+1))
			self.world_obj.st_list[1].progress((i+1)/num_runs)
			if i%(num_runs/10)==0:
				print(i)
			self.one_run()

	def get_maximum_vulnerable_agents(self,n):
		res_max = dict(sorted(self.agent_scores.items(), key = lambda x: (x[1], x[0]))[-n:])
		return res_max

	def get_minimum_vulnerable_agents(self,n):
		res_min = dict(sorted(self.agent_scores.items(), key = lambda x: (x[1], x[0]))[:n])
		return res_min

class Agent_Vulnerabilities_MC3(Agent_Vulnerabilities):
	def __init__(self, read_obj,chunk_len_range = [1,50]):
		super().__init__()
		self.read_obj=read_obj
		self.agent_scores={}
		self.agents_to_remove = None

		self.time_steps = self.read_obj.config_obj.time_steps
		self.start_agent_score = None
		self.end_agent_score = None
		self.range_list = list(range(chunk_len_range[0],chunk_len_range[1]+1))
		self.init_scores()

	def init_scores(self):
		agents_obj=ReadFile.ReadAgents(self.read_obj.agents_filename,self.read_obj.config_obj)
		for agent_index in agents_obj.agents.keys():
			self.agent_scores[agent_index]=0

	def remove_agents(self,agents_obj,num_agents_to_remove):
		agents = list(agents_obj.agents)
		self.agents_to_remove = random.sample(agents, num_agents_to_remove)
		for agent in self.agents_to_remove:
			agents_obj.agents.pop(agent)

	def reset_world(self,agents_obj):
		self.start_agent_score = None
		self.end_agent_score = None

	def get_scores(self, agents_obj):
		score=0
		for agent in agents_obj.agents.values():
			if agent.state=='Infected' or agent.state=='Recovered':
				score+=1

		return score


	def update_agent_scores(self,agents_obj, time_step, mode):
		if(mode=='start'):
			self.start_agent_score = self.get_scores(agents_obj)
		elif(mode=='end'):
			self.end_agent_score = self.get_scores(agents_obj)
			for agent in self.agents_to_remove:
				self.agent_scores[agent]+=self.end_agent_score - self.start_agent_score

	def one_run(self,num_agents_to_remove, start, end):

		agents_obj=ReadFile.ReadAgents(self.read_obj.agents_filename,self.read_obj.config_obj)
		self.reset_world(agents_obj)
		if(num_agents_to_remove>0):
			self.remove_agents(agents_obj,num_agents_to_remove)

		locations_obj=ReadFile.ReadLocations(self.read_obj.locations_filename,self.read_obj.config_obj)

		sim_obj= Simulate.Simulate(self.read_obj.config_obj,self.read_obj.model,self.read_obj.policy_list,self.read_obj.event_restriction_fn,agents_obj,locations_obj)
		sim_obj.onStartSimulation()
		flag =0
		self.read_obj.world_obj.st_list[3].progress(0.0)
		for i in range(self.time_steps):
			self.read_obj.world_obj.st_list[2].write("Simulating Time Step : {0}".format(i+1))
			self.read_obj.world_obj.st_list[3].progress((i+1)/self.time_steps)
			if self.read_obj.list_interactions_files==[] or self.read_obj.list_interactions_files==None:
				interactions_filename=None
			else:
				interactions_filename=self.read_obj.list_interactions_files[i%len(self.read_obj.list_interactions_files)]
			if self.read_obj.list_events_files==[] or self.read_obj.list_events_files==None:
				events_filename=None
			else:
				events_filename=self.read_obj.list_events_files[i%len(self.read_obj.list_events_files)]
			sim_obj.onStartTimeStep(interactions_filename,events_filename,i)
			sim_obj.handleTimeStepForAllAgents()
			sim_obj.endTimeStep()
			if(i==start):
				self.update_agent_scores(agents_obj, i, 'start')
				flag+=1
			if(i==end):
				self.update_agent_scores(agents_obj, i, 'end')
				flag+=1
				break

		end_state=sim_obj.endSimulation()
		assert flag==2


	def generate_bounds(self):
		chunk_len = random.choice(self.range_list)

		if(chunk_len<=0):
			return None, None
		if(chunk_len>=self.time_steps):
			return 0,self.time_steps-1

		start_list = list(range(self.time_steps-chunk_len+1))
		start = random.choice(start_list)
		end = start+chunk_len-1
		return start,end

	def do_MC(self,num_runs,num_agents_to_remove):
		self.read_obj.world_obj.st_list[1].progress(0.0)
		for i in range(num_runs):
			self.read_obj.world_obj.st_list[0].write("Iteration : {0}".format(i+1))
			self.read_obj.world_obj.st_list[1].progress((i+1)/num_runs)
			start, end = self.generate_bounds()
			if start is None:
				continue
			self.one_run(num_agents_to_remove, start, end)

	def get_maximum_agent_vulnerability(self,n):
		res_max = dict(sorted(self.agent_scores.items(), key = lambda x: (x[1], x[0]))[:n])
		return res_max

	def get_minimum_agent_vulnerability(self,n):
		res_min = dict(sorted(self.agent_scores.items(), key = lambda x: (x[1], x[0]))[-n:])
		return res_min
